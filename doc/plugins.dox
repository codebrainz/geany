/*
 * plugins.dox - this file is part of Geany, a fast and lightweight IDE
 *
 * Copyright 2008-2011 Enrico Tröger <enrico(dot)troeger(at)uvena(dot)de>
 * Copyright 2008-2011 Nick Treleaven <nick(dot)treleaven(at)btinternet(dot)com>
 * Copyright 2009-2012 Frank Lanitz <frank(at)frank(dot)uvena(dot)de>
 * Copyright 2013      Matthew Brush <mbrush(at)codebrainz(dot)ca>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

/*
This file contains additional plugin documentation like the signal
system and a small howto. It is best viewed when filetype is set
* to C or C++.
*/

/**

@mainpage Geany Plugin API Documentation

@author Enrico Tröger, Nick Treleaven, Frank Lanitz, Matthew Brush

@section Intro
This is the Geany API documentation. It should be considered work in 
progress. We will try to document as many functions and structs as 
possible.

@warning Do not use any symbol not in the documentation - it may change.

@section pluginsupport Plugin Support
- @link howto Plugin HowTo @endlink - get started
- @link pluginsymbols.c Plugin Symbols @endlink
- @link plugindata.h Plugin Datatypes and Macros @endlink
- @link pluginsignals.c Plugin Signals @endlink
- @link pluginutils.h Plugin Utility Functions @endlink
- @link guidelines Plugin Writing Guidelines @endlink
- <b>plugins/demoplugin.c</b> - in Geany's source, bigger than the 
howto example

@section common Common API files
- @link dialogs.h @endlink
- @link document.h @endlink
- @link editor.h @endlink
- @link filetypes.h @endlink
- @link keybindings.h @endlink
- @link msgwindow.h @endlink
- @link project.h @endlink
- @link sciwrappers.h Scintilla Wrapper Functions @endlink
- @link stash.h Stash Pref/Setting Functions @endlink
- @link utils.h General Utility Functions @endlink
- @link ui_utils.h Widget Utility Functions @endlink

@section More
- All API functions and types - see <b>Files</b> link at the top
- Deprecated symbols - see <b>Related Pages</b> link at the top

@note See the HACKING file for information about developing the 
plugin API and other useful notes.

**/

/**
@page guidelines Plugin Writing Guidelines

@section intro Introduction

The following hints and guidelines are only recommendations. Nobody 
is forced to follow them at all.

@section general General notes

@subsection ideas Getting a plugin idea

If you want to write a plugin but don't know yet what it should do, 
have a look at http://www.geany.org/Support/PluginWishlist to get an 
idea about what users wish.

@subsection code Managing the source code

For authors of plugins for Geany, we created a dedicated @a 
geany-plugins project on Sourceforge and GitHub to ease development 
of plugins and help new authors. All information about this project 
you can find at http://plugins.geany.org/

To add a new plugin to this project, get in touch with the people on 
the geany-devel-mailing list and create a fork of the geany-plugins 
project at https://github.com/geany/geany-plugins. Beside of adding 
a new plugin, geany-devel-mailing list is also the place where to 
discuss development related questions. However, once you have done 
your fork of geany-plugins you can develop your plugin until you 
think its the right time to publish it. At this point, create a pull 
request for adding your patch set into the master branch of the main 
geany-plugins repository.

Of course, you don't need to use GitHub - any Git is fine. But GitHub
is making it way easier for review, merging and get in touch with 
you for comments.

If you don't want your plugin to be part of the geany-plugins 
project it is also fine. Just skip the part about forking 
geany-plugins and sending a pull request. In this case it is of 
course also a good idea to post some kind of announcement to 
geany-devel and maybe to the main geany mailing list -- it's up to 
you. You can also ask for your plugin to be listed on the 
http://plugins.geany.org/ website as a third party plugin, helping 
Geany user to know about your plugin.

At time of writing, there are some plugins already available in the 
repositories. Feel free to use any of these plugins as a start for 
your own, maybe by copying the directory structure and the autotools 
files (Makefile.am, configure.in, ...). Most of the available 
plugins are also ready for i18n support, just for reference.

We encourage authors using this service to only commit changes to 
their own plugin and not to others' plugins. Instead just send 
patches to geany-devel at uvena.de or the plugin author directly.

@section paths Installation paths

- The plugin binary (@c pluginname.so) should be installed in 
Geany's libdir. This is necessary so that Geany can find the plugin.
An easy way to retrieve Geany's libdir is to use the pkg-config 
tool, e.g. @code `$PKG_CONFIG --variable=libdir geany`/ geany @endcode
- If your plugin creates other binary files like helper programs or 
helper libraries, they should go into @c $prefix/bin (for programs, 
ideally prefixed with @a geany), additional libraries should be 
installed in Geany's libdir, maybe in a subdirectory.
- Plugins should install their documentation files (README, NEWS, 
ChangeLog, licences and other documentation files) into the common 
documentation directory
@c $prefix/share/doc/geany-plugins/$pluginname/
- Translation files should be installed normally into @c 
$prefix/share/locale. There is no need to use Geany's translation 
directory. To set up translation support properly and for additional 
information, see main_locale_init().
- Do @a never install anything into a user's home directory like 
installing the plugin binary in @c ~/.config/geany/plugins/.

**/

/**

@page howto Plugin HowTo

@section intro Introduction

Since Geany 0.12 there is a plugin interface to extend Geany's 
functionality and add new features. This document gives a brief 
overview about how to add new plugins by writing a simple "Hello 
World" plugin in C or C++.


@section buildenv Build environment

To be able to write plugins for Geany, you need the source code and 
some development packages for GTK and its dependencies. The 
following will only describe the way to compile and build plugins on 
Unix-like systems [1].
If you already have the Geany source code and compiled it from them, 
you can skip the following.

First you need to have Geany installed. Then install the development 
files for GTK and its dependencies. The easiest way to do this is to 
use your distribution's package management system, e.g. on Debian 
and Ubuntu systems you can use @code apt-get install libgtk2.0-dev 
intltool @endcode This will install all necessary files to be able 
to compile plugins for Geany. On other distributions, the package 
names and commands to use may differ.

Basically, you are done at this point and could continue with 
writing the plugin code.

[1] For Windows, it is basically the same but you might have some 
more work on setting up the general build environment(compiler, GTK 
development files, ...). This is described on Geany's website at 
http://www.geany.org/Support/BuildingOnWin32.

@section helloworld "Hello World"

When writing a plugin, you will find a couple of functions or macros 
which are mandatory and some which are free to use for implementing 
some useful feature once your plugin becomes more powerful like 
including a configuration or help dialog.

You should start your plugin with including some of the needed C 
header files and defining some basic global variables which will 
help you to access all needed functions of the plugin API in a more 
comfortable way.

Let's start with the very basic headers and add more later if necessary.
@code
#include <geanyplugin.h>
@endcode

@a geanyplugin.h includes all of the Geany API and also the 
necessary GTK header files, so there is no need to include @a 
gtk/gtk.h yourself.

@note @a plugindata.h contains the biggest part of the plugin API 
and provides some basic macros. @a geanyfunctions.h provides some 
macros for convenient access to plugin API functions.

Next comes plugin registration. Basically this involves invoking a
macro that will install some required functions into your plugin
based on the provided arguments.

Here's what that looks like:

@code
#include <geanyplugin.h>

PLUGIN_REGISTER(1, 24, 0,
                "HelloWorld",
                "Yet another Hello World plugin",
                "0.01",
                "The Geany Developers");
@endcode

The first three arguments to the @a PLUGIN_REGISTER macro are the major,
minor and micro versions of the Geany version you want to target. The
version you use here depends on which version of Geany's plugin API
you need based on which structures and functions you use. Refer to the
API documentation "since" sections for many functions to determine
which version it was introduced in. If in doubt, it's best to refer
to Geany's version control system history to try and find the API
version at the time.

The last 4 arguments to @a PLUGIN_REGISTER provide basic information 
about the plugin for use in the plugin manager dialog. All four 
arguments are required and cannot be @c NULL.

One of the things the @a PLUGIN_REGISTER macro does is declares 3 global
variables that Geany will set when it loads the plugin. The 
declaration of them looks like this:

@code
GeanyPlugin			*geany_plugin;
GeanyData			*geany_data;
GeanyFunctions		*geany_functions;
@endcode

These variables are an artifact of earlier plugin API code and should
be generally not be needed. geany_plugin is a pointer to your
plugin which is also passed to all of the plugin functions you
implement. It is preferred to not access this symbol after Geany 1.24.
The geany_data variable is a pointer to a bunch of extremely useful
Geany structures. It is also available as the "data" member on the
GeanyPlugin structure. It is preferred to access this pointer through
the GeanyPlugin structure, for example:

@code
const gchar *
get_configdir(GeanyPlugin *plugin)
{
	return plugin->data->app->configdir;
}
@endcode

This is preferred over accessing the global variable like this:

@code
const gchar *
get_configdir(void)
{
	return geany_data->app->configdir;
}
@endcode

Because it limits future enhancements to the plugin API where there
might be more than one GeanyPlugin structure per plugin module (Think
Python, Lua, Perl, etc. bindings plugins).

Once this is done, you will need to implement the function which 
will be executed when the plugin is loaded. Part of that function 
could be adding and removing of an item to Geany's Tools menu, 
setting up keybindings or registering some callbacks. Also you will 
need to implement the function that is called when your plugin is 
unloaded. These functions are called plugin_load() and 
plugin_unload(). Let's see what this looks like:

@code
#include <geanyplugin.h>

PLUGIN_REGISTER(1, 24, 0,
                "HelloWorld",
                "Yet another Hello World plugin",
                "0.01",
                "The Geany Developers");

gboolean plugin_load(GeanyPlugin *plugin)
{
	return TRUE;
}

gboolean plugin_unload(GeanyPlugin *plugin)
{
	return TRUE;
}
@endcode

If you think this plugin seems not to implement any functionality 
right now and only wastes some memory, you are right. But it should 
compile and load/unload in Geany nicely. Now you have the very basic 
layout of a new plugin. Great, isn't it?

@note If you would rather write the plugin in C++, you can do that 
by marking the plugin functions that it implements as @c extern @c 
"C", for example:

@code
extern "C" gboolean plugin_load(GeanyPlugin *plugin)
{
	return TRUE;
}

extern "C" gboolean plugin_unload(GeanyPlugin *plugin)
{
	return TRUE;
}
@endcode

@section building Building

First we'll go over the commands needed to compile the plugin and at
the end of the section we'll see a very simple GNU Make file that you
can copy and paste into your source code to make re-building the plugin
a little bit easier.

The first thing we need to do is compile an object file. Assuing the
plugin source code is in a file called "plugin.c", we'll compile an
object file called "plugin.o":

@code
gcc -c -fPIC `pkg-config --cflags geany` -o plugin.o plugin.c
@endcode

After that we need to link the object file into a shared library (in 
this case often called a "module"). The shared library we'll make 
will be called "plugin.so" (or plugin.dll on Windows or plugin.dylib 
on Mac OS). The command to do this is:

@code
gcc -shared -o plugin.so plugin.o `pkg-config --libs geany`
@endcode

If all went OK there will be no output from either of those commands 
and there will be a "plugin.so" file in the current directory. In 
order for Geany to load this plugin it needs to be in one of the 
directories that Geany looks in for plugins. See @ref paths 
"Installation paths" for details. For the purpose of this tutorial, 
we'll copy the plugin into your own config directory to avoid 
permissions issues. On a typical Linux machine the path is 
"~/.config/geany/plugins/". So we could copy the "plugin.so" file to 
that directory and Geany will see it.

@code
cp "plugin.so" ~/.config/geany/plugins/
@endcode

And when you're done messing around with it, you can delete it like
this:

@code
rm ~/.config/geany/plugins/plugin.so
@endcode

@note It's import to note that this IS NOT a good place to typically 
install plugins, particularly if you're sharing them with other 
people. This is only being used for learning a simple Hello World 
plugin, if you make a real plugin you should investigate using a 
real build system like Autotools, CMake, Waf, etc.

@note If you are writing the plugin in C++, then you will need to 
use your C++ compiler here, for example @c g++.

@subsection simple_makefile A Simple GNU Make File

To make it easier to re-build your plugin and to integrate with the
default build commands in Geany (especially useful if you're using
a Geany project for your plugin's source code), here's a little
barebones GNU Make file that will compile, install, uninstall,
and clean the plugin.

@code
PLUGIN_CFLAGS = -g -Wall `pkg-config --cflags geany` $(CFLAGS)
PLUGIN_LDFLAGS = `pkg-config --libs geany` $(LDFLAGS)

plugin.so: plugin.o
	$(CC) -shared -o $@ $^ $(PLUGIN_LDFLAGS)

plugin.o: plugin.c
	$(CC) -c -fPIC $(PLUGIN_CFLAGS) -o $@ $<

install:
	cp plugin.so ~/.config/geany/plugins/

uninstall:
	rm -f ~/.config/geany/plugins/plugin.so

clean:
	rm -f plugin.o plugin.so
@endcode

Save that to a file named "Makefile" in the same directory as your
plugin's source code, obviously renaming the plugin's filename if you
aren't using "plugin". The various rules can be invoked by passing
their name to the "make" command, for example:

@code
make           # compile the .so file by default
make install   # copy the .so file into the ~ plugins dir
make uninstall # remove the .so file from that dir
make clean     # remove compiled files leaving only the source files
@endcode

@note As mentioned earlier the installation path is not ideal for
real use and you certainly would'nt want to distribute your plugin
using this Make file, it's just to get you up and running quick on
the actual interesting parts of this endeavor (writing the plugin).

@section realfunc Adding functionality

Let's go on and implement some real functionality.

As mentioned before, plugin_load() will be called when the plugin is 
loaded in Geany. So it should implement everything that needs to be 
done during startup. In this case, we'd like to add a menu item to 
Geany's Tools menu which runs a dialog printing "Hello World".

@code
gboolean plugin_load(GeanyPlugin *plugin)
{
	GtkWidget *main_menu_item;
	GtkWidget *tools_menu;

	// Create a new menu item and show it
	main_menu_item = gtk_menu_item_new_with_mnemonic("Hello World");
	gtk_widget_show(main_menu_item);

	// Attach the new menu item to the Tools menu
	tools_menu = plugin->data->main_widgets->tools_menu;
	gtk_container_add(GTK_CONTAINER(tools_menu), main_menu_item);

	// Connect the menu item with a callback function which is called
	// when the item is clicked passing a pointer to the plugin along
	g_signal_connect(main_menu_item, "activate",
		G_CALLBACK(item_activate_cb), plugin);

	// Make this a "field" of the plugin so that it gets deleted
	// when the plugin is unloaded.
	plugin_set_field(plugin, "main-menu-item", main_menu_item,
		(GDestroyNotify) gtk_widget_destroy);

	return TRUE; // Let Geany know that the plugin loaded OK
}
@endcode

This will add an item to the Tools menu and connect this item to a 
function which implements what should be done when the menu item is 
activated by the user. This is done by g_signal_connect(). The Tools 
menu can be accessed with plugin->data->main_widgets->tools_menu. 
The structure @a main_widgets contains pointers to the main GUI 
elements in Geany.

You might be wondering about that last function call to 
plugin_set_field(). Each GeanyPlugin has a hash table associated 
with it that can store arbitrary pointers for the plugin. The first 
parameter is the plugin to set the field on, the 2nd parameter is a 
name to associate with the field, the 3rd parameter is the pointer 
to set for the field's value and the last argument is a pointer to a 
function that can destroy the value pointer (or @c NULL if not 
needed).

When a plugin is unloaded, it's hash table is also destroyed which 
invokes the "free_func" function pointer passed to the 4th argument 
on the pointer stored in the field's value. You can think of like a 
poor man's garbage collector and data store. Often you'll create 
resources which need to be cleaned up when the plugin is unloading 
or you'll need to pass some information from one function to the 
next without using extra arguments (ex. signal callbacks). Using the 
plugin's fields is ideal for this and can often avoid cluttering up 
the global scope with variables used to share information between 
functions. Always pass a pointer to you GeanyPlugin and you're all 
set.

Continuing along, we'll write our "item_activate_cb" callback 
function which will get called when the menu item we added gets 
activated (clicked).

Geany has a simple API for showing message dialogs. So our function 
contains only a few lines:

@code
void item_activate_cb(GtkMenuItem *menuitem, GeanyPlugin *plugin)
{
	dialogs_show_msgbox(GTK_MESSAGE_INFO,
		"Hello World (from plugin %s)", plugin->info->name);
}
@endcode

The first parameter the item_activate_cb function is the menu item
that was activated, in this case the one we added to the Tools menu.
The second parameter is the pointer to our GeanyPlugin structure that
we passed to g_signal_connect() in plugin_load().

There's one more part of the plugin API you'll likely want to 
implement to something before the plugin gets unloaded such as 
releasing memory back to the system, closing files, etc. You do this 
by defining the plugin_unload() function.

Since we used the plugin's fields to have it destroyed when the plugin
is unloaded, for this example we don't really need to implement it,
but for completeness we'll print a message to the console showing that
the plugin was unloaded:

@code
gboolean plugin_unload(GeanyPlugin *plugin)
{
	g_print("Plugin %s is unloading...\n", plugin->info->name);
	return TRUE;
}
@endcode

You always pass @c TRUE back to Geany as the return value of this
function so it knows it can safely unload it. Very rarely will you
need to return @c FALSE. See the API documentation for this plugin
for more information.

@warning It's absolutely CRITICAL that you remove any UI elements 
you added to Geany and/or release any resources that were used. Not 
doing this can lead not only to memory leaks but also strange 
crashes when the plugin is reloaded. When writing your plugin it's 
important to test that it can load and unload cleanly.

@section listing Complete listing (without comments)

@code
#include <geanyplugin.h>

PLUGIN_REGISTER(
	1, 24, 0,
	"HelloWorld",
	"Just another tool to say hello world",
	"1.0",
	"John Doe <john.doe@example.org>"
);

void item_activate_cb(GtkMenuItem *menuitem, GeanyPlugin *plugin)
{
	dialogs_show_msgbox(GTK_MESSAGE_INFO,
		"Hello World (from plugin %s)", plugin->info->name);
}

gboolean plugin_load(GeanyPlugin *plugin)
{
	GtkWidget *main_menu_item;
	GtkWidget *tools_menu;

	main_menu_item = gtk_menu_item_new_with_mnemonic("Hello World");
	gtk_widget_show(main_menu_item);

	tools_menu = plugin->data->main_widgets->tools_menu;
	gtk_container_add(GTK_CONTAINER(tools_menu), main_menu_item);

	g_signal_connect(main_menu_item, "activate",
		G_CALLBACK(item_activate_cb), plugin);

	plugin_set_field(plugin, "main-menu-item", main_menu_item,
		(GDestroyNotify) gtk_widget_destroy);

	return TRUE;
}

gboolean plugin_unload(GeanyPlugin *plugin)
{
	g_print("Plugin %s is unloading...\n", plugin->info->name);
	return TRUE;
}
@endcode


Now you might like to look at Geany's source code for core plugins 
such as @a plugins/demoplugin.c.

@section furtherimprovements Furter Improvements and next steps
@subsection translatable_plugin_information Translatable plugin information

After having written our first plugin, there is still room for 
improvement.

If you are using Gettext to translate your plugin, you should ensure
that LOCALEDIR and GETTEXT_PACKAGE are defined prior to including
the "geanyplugins.h" header. This will allow the @a PLUGIN_REGISTER
macro to initialize the translations system for you. 

If you're using Autoconf along with Gettext, often this means simply
including the "config.h" (or equivalent) header before the
"geanyplugins.h" header for example:

@code
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif
#include <geanyplugins.h>

PLUGIN_REGISTER(...);
@endcode

This allows the plugin name and description passed to @a 
PLUGIN_REGISTER to marked translatable with the @c _ macro (ex. 
`_("Your plugin name")`).

@note If you're not using Gettext, you'll need to arrange to 
initialize your translation system yourself.

@note The author name passed to @a PLUGIN_REGISTER is not marked 
translatable automatically with the @c _ macro. The community has 
agreed that the best practice here is to use, if possible, the latin 
version of the author's name followed by the native spelling inside 
parenthesis, where applicable. Of course every rule has exceptions, 
as a silly example, if your plugin author is "ACME Inc. Development 
Team" you can mark the author string as translatable like this:

@code 
PLUGIN_REGISTER(1, 24, 0
                "HelloWorld",
                "Yet Another Hello World Plugin",
                "0.01",
                _("ACME Inc. Development Team"));
@endcode

@subsection plugin_i18n Using i18n/l10n inside Plugin

You can (and should) also mark other strings beside the plugin's meta
information as translatable.  Strings used in menu entries, 
information boxes or configuration dialogs should also be 
translatable as well.

**/
